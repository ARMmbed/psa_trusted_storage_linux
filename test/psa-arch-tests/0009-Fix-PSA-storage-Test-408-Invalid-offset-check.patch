From e31bd5f8a70274bb737ce7013623309968a6b657 Mon Sep 17 00:00:00 2001
From: Simon Hughes <simon.hughes@arm.com>
Date: Wed, 2 Oct 2019 14:39:55 +0100
Subject: [PATCH 09/15] Fix PSA storage Test 408 - Invalid offset check.

The following provides more information about this commit:
- SST_FUNCTION() macro uses variadic functions. Use of this macro
  resets data_len = 0 after use, for an unknown reason. data_len
  is then used in test checkpoints which fail as its value is not
  as expected.
- This commit implements workarounds to recalculate data_len
  before making the test checkpoints.
---
 .../internal_trusted_storage/test_s006/test_s006.c | 50 ++++++++++++++++++++++
 1 file changed, 50 insertions(+)

diff --git a/api-tests/dev_apis/internal_trusted_storage/test_s006/test_s006.c b/api-tests/dev_apis/internal_trusted_storage/test_s006/test_s006.c
index a45351a..59db113 100755
--- a/api-tests/dev_apis/internal_trusted_storage/test_s006/test_s006.c
+++ b/api-tests/dev_apis/internal_trusted_storage/test_s006/test_s006.c
@@ -63,8 +63,58 @@ int32_t psa_sst_flags_not_supported(caller_security_t caller)
    /* Calling set function with different create flag value */
 
    val->print(PRINT_TEST, "[Check 1] Call set API with valid flag values\n", 0);
+
+   /* The test is incorrect in that it sets a flag bit when an object
+    * is created, and expects the bit always to be set in the flags retrieved by
+    * psa_xx_get_info(). The specification defines this is not always the case.
+    *
+    * The following outlines psuedo-code for this test:
+    *
+    *  set create_flags = 0x800000000
+    *  while (create_flags != 0)
+    *    {
+    *      psa_ps_set()
+    *      psa_ps_get()
+    *      // check xxx
+    *      psa_ps_get_info()
+    *      // check flag retrieved is the same at the value used to set
+    *      psa_ps_remove()
+    *      create_flags >>= 1
+    *    }
+    * However:
+    *   - This test doesn't respect the behaviour of defined flags:
+    *       - PSA_STORAGE_FLAG_WRITE_ONCE
+    *           - If this bit is set then the object cannot be deleted.
+    *             psa_xx_remove() will fail but the test current checks the
+    *             object can successfully be removed.
+    *       - PSA_STORAGE_FLAG_NO_CONFIDENTIALITY
+    *           - The psa_trusted_storage_linux implementation always stores
+    *             files with authentication (because files are stored with
+    *             ecryptfs). Therefore if _NO_CONFIDENTIALITY is requested then
+    *             its accepted but files are still stored confidentially. This
+    *             is allowed by the spec. The spec also says that if this
+    *             happens the the _NO_CONFIDENTIALITY flag should not be
+    *             reported with get_info().
+    *       - PSA_STORAGE_FLAG_NO_REPLAY_PROTECTION
+    *           - This flags should be observed with the psa_xx_get_info()
+    *             after creation.
+    *  - Only 3 of the flag bits are defined. The specification should be
+    *    modified to say something 1) the undefined flag bits
+    *    are reserved and the operation of the flags is undefined, or 2)
+    *    if flag bit is set then the value should be retained with the object
+    *    i.e. the behaviour being tested for here.
+    * The solution if to not test for the following flags:
+    *   - PSA_STORAGE_FLAG_WRITE_ONCE
+    *   - PSA_STORAGE_FLAG_NO_CONFIDENTIALITY
+    */
+
    while (flag)
    {
+       if ( (flag & PSA_STORAGE_FLAG_WRITE_ONCE) || (flag & PSA_STORAGE_FLAG_NO_CONFIDENTIALITY) )
+       {
+           flag = flag >> 1;
+           continue;
+       }
        /* Create storage with flag value */
        status = SST_FUNCTION(s006_data[1].api, uid, TEST_BUFF_SIZE, write_buff,
                                                          (flag & (~PSA_STORAGE_FLAG_WRITE_ONCE)));
-- 
2.7.4

